/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


/*
 * Copyright (C) 2015 Clover Network, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.clover.sdk.v3.apps;

@SuppressWarnings("all")
public final class AppBillingInfo implements android.os.Parcelable, com.clover.sdk.v3.Validator, com.clover.sdk.JSONifiable {

 /**
   * Current subscription level of merchant for this app.
  */
  public com.clover.sdk.v3.apps.AppSubscription getAppSubscription() {
    return cacheGet(CacheKey.appSubscription);
  }
 /**
   * Whether merchant is in trial for this app.  Only valid for paid apps that offer trials.  Keep in mind, trials apply to app metereds as well.
  */
  public java.lang.Boolean getIsInTrial() {
    return cacheGet(CacheKey.isInTrial);
  }
 /**
   * When the merchant's trial ends.  Only valid for paid apps that offer trials.
  */
  public java.lang.Long getBillingStartTime() {
    return cacheGet(CacheKey.billingStartTime);
  }
 /**
   * Note, this info is merchant-level, not merchant-app-level, but including here for developer convenience.  Returns active if a merchant has a credit card on file, and if it's currently authorizing properly.  Returns lapsed if their card is absent or most recently declined.  Currently, we only accept credit cards as payment, but may add other payment methods in the future.
  */
  public com.clover.sdk.v3.apps.MerchantBillingStatus getStatus() {
    return cacheGet(CacheKey.status);
  }
 /**
   * If the merchant's account is lapsed, the number of days since it lapsed.
  */
  public java.lang.Long getDaysLapsed() {
    return cacheGet(CacheKey.daysLapsed);
  }


  private enum CacheKey {
    appSubscription {
      @Override
      public Object extractValue(AppBillingInfo instance) {
        return instance.extractAppSubscription();
      }
    },
    isInTrial {
      @Override
      public Object extractValue(AppBillingInfo instance) {
        return instance.extractIsInTrial();
      }
    },
    billingStartTime {
      @Override
      public Object extractValue(AppBillingInfo instance) {
        return instance.extractBillingStartTime();
      }
    },
    status {
      @Override
      public Object extractValue(AppBillingInfo instance) {
        return instance.extractStatus();
      }
    },
    daysLapsed {
      @Override
      public Object extractValue(AppBillingInfo instance) {
        return instance.extractDaysLapsed();
      }
    },
    ;

    public abstract Object extractValue(AppBillingInfo instance);
  }

  private org.json.JSONObject jsonObject = null;
  private android.os.Bundle bundle = null;
  private android.os.Bundle changeLog = null;
  private Object[] cache = null;
  private byte[] cacheState = null;

  private static final byte STATE_NOT_CACHED = 0;
  private static final byte STATE_CACHED_NO_VALUE = 1;
  private static final byte STATE_CACHED_VALUE = 2;

  /**
   * Constructs a new empty instance.
   */
  public AppBillingInfo() { }

  /**
   * Constructs a new instance from the given JSON String.
   */
  public AppBillingInfo(String json) throws java.lang.IllegalArgumentException {
    try {
      this.jsonObject = new org.json.JSONObject(json);
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException("invalid json", e);
    }
  }

  /**
   * Construct a new instance backed by the given JSONObject, the parameter is not copied so changes to it will be
   * reflected in this instance and vice-versa.
   */
  public AppBillingInfo(org.json.JSONObject jsonObject) {
    this.jsonObject = jsonObject;
  }

  /**
   * Constructs a new instance that is a deep copy of the source instance. It does not copy the bundle or changelog.
   */
  public AppBillingInfo(AppBillingInfo src) {
    if (src.jsonObject != null) {
      this.jsonObject = com.clover.sdk.v3.JsonHelper.deepCopy(src.getJSONObject());
    }
  }

  private <T> T cacheGet(CacheKey key) {
    int index = key.ordinal();
    populateCache(index);
    return (T) cache[index];
  }

  private boolean cacheValueIsNotNull(CacheKey key) {
    int index = key.ordinal();
    populateCache(index);
    return cache[index] != null;
  }

  private boolean cacheHasKey(CacheKey key) {
    int index = key.ordinal();
    populateCache(index);
    return cacheState[index] == STATE_CACHED_VALUE;
  }

  private void cacheRemoveValue(CacheKey key) {
    int index = key.ordinal();
    populateCache(index);
    cache[index] = null;
    cacheState[index] = STATE_CACHED_NO_VALUE;
  }

  private void cacheMarkDirty(CacheKey key) {
    if (cache != null) {
      int index = key.ordinal();
      cache[index] = null;
      cacheState[index] = STATE_NOT_CACHED;
    }
  }

  private void populateCache(int index) {
    if (cache == null) {
      int size = CacheKey.values().length;
      cache = new Object[size];
      cacheState = new byte[size];
    }

    if (cacheState[index] == STATE_NOT_CACHED) {
      CacheKey key = CacheKey.values()[index];

      if (getJSONObject().has(key.name())) {
        cache[index] = key.extractValue(this);
        cacheState[index] = STATE_CACHED_VALUE;
      } else {
        cacheState[index] = STATE_CACHED_NO_VALUE;
      }
    }
  }

  /**
   * Returns the internal JSONObject backing this instance, the return value is not a copy so changes to it will be
   * reflected in this instance and vice-versa.
   */
  public org.json.JSONObject getJSONObject() {
    if (jsonObject == null) {
      jsonObject = new org.json.JSONObject();
    }
    return jsonObject;
  }


  @Override
  public void validate() {
  }



  private com.clover.sdk.v3.apps.AppSubscription extractAppSubscription() {
    org.json.JSONObject jsonObj = getJSONObject().optJSONObject("appSubscription");
    if (jsonObj != null) {
      return new com.clover.sdk.v3.apps.AppSubscription(getJSONObject().optJSONObject("appSubscription"));
    }
    return null;
  }


  private java.lang.Boolean extractIsInTrial() {
    return getJSONObject().isNull("isInTrial") ? null :
      getJSONObject().optBoolean("isInTrial");
  }


  private java.lang.Long extractBillingStartTime() {
    return getJSONObject().isNull("billingStartTime") ? null :
      getJSONObject().optLong("billingStartTime");
  }


  private com.clover.sdk.v3.apps.MerchantBillingStatus extractStatus() {
    if (!getJSONObject().isNull("status")) {
      try {
        return com.clover.sdk.v3.apps.MerchantBillingStatus.valueOf(getJSONObject().optString("status"));
      } catch(Exception e) {
        e.printStackTrace();
      }
    }

    return null;
  }


  private java.lang.Long extractDaysLapsed() {
    return getJSONObject().isNull("daysLapsed") ? null :
      getJSONObject().optLong("daysLapsed");
  }


  /** Checks whether the 'appSubscription' field is set and is not null */
  public boolean isNotNullAppSubscription() {
    return cacheValueIsNotNull(CacheKey.appSubscription);
  }

  /** Checks whether the 'isInTrial' field is set and is not null */
  public boolean isNotNullIsInTrial() {
    return cacheValueIsNotNull(CacheKey.isInTrial);
  }

  /** Checks whether the 'billingStartTime' field is set and is not null */
  public boolean isNotNullBillingStartTime() {
    return cacheValueIsNotNull(CacheKey.billingStartTime);
  }

  /** Checks whether the 'status' field is set and is not null */
  public boolean isNotNullStatus() {
    return cacheValueIsNotNull(CacheKey.status);
  }

  /** Checks whether the 'daysLapsed' field is set and is not null */
  public boolean isNotNullDaysLapsed() {
    return cacheValueIsNotNull(CacheKey.daysLapsed);
  }


  /** Checks whether the 'appSubscription' field has been set, however the value could be null */
  public boolean hasAppSubscription() {
    return cacheHasKey(CacheKey.appSubscription);
  }

  /** Checks whether the 'isInTrial' field has been set, however the value could be null */
  public boolean hasIsInTrial() {
    return cacheHasKey(CacheKey.isInTrial);
  }

  /** Checks whether the 'billingStartTime' field has been set, however the value could be null */
  public boolean hasBillingStartTime() {
    return cacheHasKey(CacheKey.billingStartTime);
  }

  /** Checks whether the 'status' field has been set, however the value could be null */
  public boolean hasStatus() {
    return cacheHasKey(CacheKey.status);
  }

  /** Checks whether the 'daysLapsed' field has been set, however the value could be null */
  public boolean hasDaysLapsed() {
    return cacheHasKey(CacheKey.daysLapsed);
  }


  /**
   * Sets the field 'appSubscription'.
   *
   * The parameter is not copied so changes to it will be reflected in this instance and vice-versa.
   */
  public AppBillingInfo setAppSubscription(com.clover.sdk.v3.apps.AppSubscription appSubscription) {
    logChange("appSubscription");

    try {
      getJSONObject().put("appSubscription",
          appSubscription == null ? org.json.JSONObject.NULL : appSubscription.getJSONObject());
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }

    cacheMarkDirty(CacheKey.appSubscription);
    return this;
  }

  /**
   * Sets the field 'isInTrial'.
   */
  public AppBillingInfo setIsInTrial(java.lang.Boolean isInTrial) {
    logChange("isInTrial");

    try {
      getJSONObject().put("isInTrial", isInTrial == null ? org.json.JSONObject.NULL : com.clover.sdk.v3.JsonHelper.toJSON(isInTrial));
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }

    cacheMarkDirty(CacheKey.isInTrial);
    return this;
  }

  /**
   * Sets the field 'billingStartTime'.
   */
  public AppBillingInfo setBillingStartTime(java.lang.Long billingStartTime) {
    logChange("billingStartTime");

    try {
      getJSONObject().put("billingStartTime", billingStartTime == null ? org.json.JSONObject.NULL : com.clover.sdk.v3.JsonHelper.toJSON(billingStartTime));
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }

    cacheMarkDirty(CacheKey.billingStartTime);
    return this;
  }

  /**
   * Sets the field 'status'.
   */
  public AppBillingInfo setStatus(com.clover.sdk.v3.apps.MerchantBillingStatus status) {
    logChange("status");

    try {
      getJSONObject().put("status", status == null ? org.json.JSONObject.NULL : com.clover.sdk.v3.JsonHelper.toJSON(status));
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }

    cacheMarkDirty(CacheKey.status);
    return this;
  }

  /**
   * Sets the field 'daysLapsed'.
   */
  public AppBillingInfo setDaysLapsed(java.lang.Long daysLapsed) {
    logChange("daysLapsed");

    try {
      getJSONObject().put("daysLapsed", daysLapsed == null ? org.json.JSONObject.NULL : com.clover.sdk.v3.JsonHelper.toJSON(daysLapsed));
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }

    cacheMarkDirty(CacheKey.daysLapsed);
    return this;
  }


  /** Clears the 'appSubscription' field, the 'has' method for this field will now return false */
  public void clearAppSubscription() {
    unlogChange("appSubscription");
    getJSONObject().remove("appSubscription");
    cacheRemoveValue(CacheKey.appSubscription);
  }

  /** Clears the 'isInTrial' field, the 'has' method for this field will now return false */
  public void clearIsInTrial() {
    unlogChange("isInTrial");
    getJSONObject().remove("isInTrial");
    cacheRemoveValue(CacheKey.isInTrial);
  }

  /** Clears the 'billingStartTime' field, the 'has' method for this field will now return false */
  public void clearBillingStartTime() {
    unlogChange("billingStartTime");
    getJSONObject().remove("billingStartTime");
    cacheRemoveValue(CacheKey.billingStartTime);
  }

  /** Clears the 'status' field, the 'has' method for this field will now return false */
  public void clearStatus() {
    unlogChange("status");
    getJSONObject().remove("status");
    cacheRemoveValue(CacheKey.status);
  }

  /** Clears the 'daysLapsed' field, the 'has' method for this field will now return false */
  public void clearDaysLapsed() {
    unlogChange("daysLapsed");
    getJSONObject().remove("daysLapsed");
    cacheRemoveValue(CacheKey.daysLapsed);
  }


  private void logChange(java.lang.String field) {
    if (changeLog == null) {
      changeLog = new android.os.Bundle();
    }
    changeLog.putString(field, null);
  }

  private void unlogChange(java.lang.String field) {
    if (changeLog != null) {
      changeLog.remove(field);
    }
  }

  /**
   * Returns true if this instance has any changes.
   */
  public boolean containsChanges() {
    return changeLog != null;
  }

  /**
   * Reset the log of changes made to this instance, calling copyChanges() after this would return an empty instance.
   */
  public void resetChangeLog() {
    changeLog = null;
  }

  /**
   * Create a copy of this instance that contains only fields that were set after the constructor was called.
   */
  public AppBillingInfo copyChanges() {
    AppBillingInfo copy = new AppBillingInfo();
    copy.mergeChanges(this);
    copy.resetChangeLog();
    return copy;
  }

  /**
   * Copy all the changed fields from the given source to this instance.
   */
  public void mergeChanges(AppBillingInfo src) {
    if (src.changeLog != null) {
      try {
        // Make a copy of the source so the destination fields are copies
        org.json.JSONObject srcObj = new AppBillingInfo(src).getJSONObject();
        org.json.JSONObject dstObj = getJSONObject();
        for (java.lang.String field : src.changeLog.keySet()) {
          dstObj.put(field, srcObj.get(field));
          logChange(field);
        }
      } catch (org.json.JSONException e) {
        throw new java.lang.IllegalArgumentException(e);
      }
    }
  }


  /**
   * Gets a Bundle which can be used to get and set data attached to this instance. The attached Bundle will be
   * parcelled but not jsonified.
   */
  public android.os.Bundle getBundle() {
    if (bundle == null) {
      bundle = new android.os.Bundle();
    }
    return bundle;
  }

  @Override
  public String toString() {
    String json = getJSONObject().toString();

    if (bundle != null) {
      bundle.isEmpty(); // Triggers unparcel
    }

    if (changeLog != null) {
      changeLog.isEmpty(); // Triggers unparcel
    }

    return "AppBillingInfo{" +
        "json='" + json + "'" +
        ", bundle=" + bundle +
        ", changeLog=" + changeLog +
        '}';
  }

  @Override
  public int describeContents() {
    return 0;
  }

  @Override
  public void writeToParcel(android.os.Parcel dest, int flags) {
	  com.clover.sdk.v3.JsonParcelHelper.wrap(getJSONObject()).writeToParcel(dest, 0);
    dest.writeBundle(bundle);
    dest.writeBundle(changeLog);
  }

  public static final android.os.Parcelable.Creator<AppBillingInfo> CREATOR = new android.os.Parcelable.Creator<AppBillingInfo>() {
    @Override
    public AppBillingInfo createFromParcel(android.os.Parcel in) {
      AppBillingInfo instance = new AppBillingInfo(com.clover.sdk.v3.JsonParcelHelper.ObjectWrapper.CREATOR.createFromParcel(in).unwrap());
      instance.bundle = in.readBundle(getClass().getClassLoader());
      instance.changeLog = in.readBundle();
      return instance;
    }

    @Override
    public AppBillingInfo[] newArray(int size) {
      return new AppBillingInfo[size];
    }
  };

  public static final com.clover.sdk.JSONifiable.Creator<AppBillingInfo> JSON_CREATOR = new com.clover.sdk.JSONifiable.Creator<AppBillingInfo>() {
    @Override
    public AppBillingInfo create(org.json.JSONObject jsonObject) {
      return new AppBillingInfo(jsonObject);
    }
  };


  public interface Constraints {

    public static final boolean APPSUBSCRIPTION_IS_REQUIRED = false;

    public static final boolean ISINTRIAL_IS_REQUIRED = false;

    public static final boolean BILLINGSTARTTIME_IS_REQUIRED = false;

    public static final boolean STATUS_IS_REQUIRED = false;

    public static final boolean DAYSLAPSED_IS_REQUIRED = false;

  }

}
